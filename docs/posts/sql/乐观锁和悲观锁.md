<!--
 * @Author: JavaPub
 * @Date: 2024-05-30 21:28:07
 * @LastEditors: your name
 * @LastEditTime: 2024-05-30 21:28:17
 * @Description: Here is the JavaPub code base. Search JavaPub on the whole web.
 * @FilePath: \JavaPub-Blog\docs\posts\sql\乐观锁和悲观锁.md
-->

> 乐观锁 or 悲观锁 你怎么选？


你有没有听过这样一句话：悲观者正确，乐观者成功​。那么今天我来分享下什么是乐观锁​和悲观锁。

![2c1afc4fa657c97734003819c0785be2](https://javapub-common-oss.oss-cn-beijing.aliyuncs.com/javapub/2024%2F05%2F30%2F20240530-213607.jpeg)

乐观锁和悲观锁有什么区别，它们什么场景会用

### 乐观锁

乐观锁基于这样的假设：多个事务在同一时间对同一数据对象进行操作的可能性很小，因此它允许多个事务同时进行，仅在事务提交时检查是否有其他事务对数据进行了修改。

**特点**：

- **无锁**：乐观锁通常不使用数据库的锁定机制，而是通过其他方式（如时间戳、版本号）来确保数据一致性。
- **性能**：在冲突较少的情况下，乐观锁可以提供更好的性能，因为它允许高并发。
- **冲突检测**：在事务提交时检测冲突，如果检测到冲突，事务将被回滚。

**实现方式**：

- **版本号**：在数据表中添加一个版本号字段或时间戳字段。事务开始时记录版本号，提交时检查版本号是否发生变化，如果变化了，则表示有冲突。
- **时间戳**：使用时间戳来控制事务的顺序，如果检测到时间戳冲突，则回滚事务。

**适用场景**：

- **写冲突较少**：适用于写操作不频繁或者写冲突可能性较低的场景。
- **读多写少**：适用于读操作远多于写操作的环境。
- **高并发**：需要支持高并发访问的系统。

### 悲观锁

悲观锁基于这样的假设：多个事务对同一数据对象的并发操作会产生冲突，因此它在事务开始时就对数据对象加锁，直到事务结束才释放锁。

**特点**：

- **锁定**：悲观锁通过数据库的锁定机制来确保数据一致性，如行锁或表锁。
- **性能**：在高冲突环境下，悲观锁可能导致更多的等待和锁竞争，从而影响性能。
- **预防冲突**：通过锁定机制预防冲突，而不是检测冲突。

**实现方式**：

- **显式锁定**：使用数据库的锁定命令（如`SELECT ... FOR UPDATE`）来显式地锁定需要的资源。
- **隐式锁定**：通过数据库事务的隔离级别隐式地实现锁定。

**适用场景**：

- **写冲突较多**：适用于写操作频繁或者写冲突可能性较高的场景。
- **写多读少**：适用于写操作多于读操作的环境。
- **数据一致性要求高**：需要严格保证数据一致性的场合。

